from fastapi import FastAPI, APIRouter, HTTPException, BackgroundTasks, UploadFile, File, Form
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
import os
import logging
import uuid
import json
import shutil
from datetime import datetime
from pathlib import Path
from pydantic import BaseModel, Field
from typing import List, Optional, Dict
import asyncio
import aiofiles
import aiosqlite
from openai import AsyncOpenAI
from PIL import Image
import re

# Load environment variables
ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# Create directories
UPLOAD_DIR = ROOT_DIR / "uploads"
TOURS_DIR = ROOT_DIR / "tours"
UPLOAD_DIR.mkdir(exist_ok=True)
TOURS_DIR.mkdir(exist_ok=True)

# OpenAI configuration
OPENAI_API_KEY = os.environ.get('OPENAI_API_KEY')
openai_client = AsyncOpenAI(api_key=OPENAI_API_KEY) if OPENAI_API_KEY and OPENAI_API_KEY != 'demo-key-for-testing' else None

# Create the main app
app = FastAPI(title="ListingSpark AI", description="AI-powered property listings with 360° virtual tours")

# Mount static files
app.mount("/tours", StaticFiles(directory=str(TOURS_DIR)), name="tours")
app.mount("/uploads", StaticFiles(directory=str(UPLOAD_DIR)), name="uploads")

# Create API router
api_router = APIRouter(prefix="/api")

# Database setup
DATABASE_PATH = ROOT_DIR / "listingspark.db"

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

async def init_db():
    """Initialize SQLite database"""
    async with aiosqlite.connect(DATABASE_PATH) as db:
        await db.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id TEXT PRIMARY KEY,
                email TEXT UNIQUE NOT NULL,
                name TEXT NOT NULL,
                plan TEXT DEFAULT 'free',
                listings_created INTEGER DEFAULT 0,
                total_views INTEGER DEFAULT 0,
                total_shares INTEGER DEFAULT 0,
                viral_score_average REAL DEFAULT 0.0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        await db.execute("""
            CREATE TABLE IF NOT EXISTS properties (
                id TEXT PRIMARY KEY,
                user_id TEXT NOT NULL,
                title TEXT NOT NULL,
                description TEXT NOT NULL,
                address TEXT NOT NULL,
                price TEXT NOT NULL,
                property_type TEXT NOT NULL,
                bedrooms INTEGER,
                bathrooms REAL,
                square_feet INTEGER,
                features TEXT,
                has_tour BOOLEAN DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
        """)
        
        await db.execute("""
            CREATE TABLE IF NOT EXISTS virtual_tours (
                id TEXT PRIMARY KEY,
                property_id TEXT NOT NULL,
                tour_name TEXT NOT NULL,
                tour_url TEXT NOT NULL,
                thumbnail_url TEXT,
                processing_status TEXT DEFAULT 'pending',
                tour_type TEXT DEFAULT '360_image',
                scene_count INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (property_id) REFERENCES properties (id)
            )
        """)
        
        await db.execute("""
            CREATE TABLE IF NOT EXISTS tour_scenes (
                id TEXT PRIMARY KEY,
                tour_id TEXT NOT NULL,
                scene_name TEXT NOT NULL,
                image_url TEXT NOT NULL,
                scene_order INTEGER DEFAULT 0,
                pitch REAL DEFAULT 0,
                yaw REAL DEFAULT 0,
                fov REAL DEFAULT 100,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (tour_id) REFERENCES virtual_tours (id)
            )
        """)
        
        await db.execute("""
            CREATE TABLE IF NOT EXISTS viral_content (
                id TEXT PRIMARY KEY,
                property_id TEXT NOT NULL,
                platform TEXT NOT NULL,
                content_type TEXT NOT NULL,
                content TEXT NOT NULL,
                viral_score INTEGER NOT NULL,
                hashtags TEXT,
                ai_generated BOOLEAN DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (property_id) REFERENCES properties (id)
            )
        """)
        
        await db.execute("""
            CREATE TABLE IF NOT EXISTS analytics (
                property_id TEXT PRIMARY KEY,
                views INTEGER DEFAULT 0,
                shares INTEGER DEFAULT 0,
                engagement_rate REAL DEFAULT 0.0,
                viral_score INTEGER DEFAULT 0,
                tour_views INTEGER DEFAULT 0,
                trending_status TEXT DEFAULT 'normal',
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (property_id) REFERENCES properties (id)
            )
        """)
        
        await db.commit()
        logger.info("Database initialized successfully")

# Pydantic Models
class UserCreate(BaseModel):
    email: str
    name: str

class User(BaseModel):
    id: str
    email: str
    name: str
    plan: str = "free"
    listings_created: int = 0

class PropertyCreate(BaseModel):
    title: str
    description: str
    address: str
    price: str
    property_type: str
    bedrooms: Optional[int] = None
    bathrooms: Optional[float] = None
    square_feet: Optional[int] = None
    features: List[str] = []

class Property(BaseModel):
    id: str
    user_id: str
    title: str
    description: str
    address: str
    price: str
    property_type: str
    bedrooms: Optional[int] = None
    bathrooms: Optional[float] = None
    square_feet: Optional[int] = None
    features: List[str] = []
    has_tour: bool = False
    created_at: str

# 360 Tour Processor
class Tour360Processor:
    """Process 360-degree equirectangular images for virtual tours"""
    
    MIN_WIDTH = 2048
    MIN_HEIGHT = 1024
    WEB_WIDTH = 4096
    WEB_HEIGHT = 2048
    THUMBNAIL_SIZE = (400, 200)
    
    @staticmethod
    def validate_360_image(image_path: str) -> tuple:
        """Validate if image is suitable for 360° viewing"""
        try:
            with Image.open(image_path) as img:
                width, height = img.size
                aspect_ratio = width / height
                
                if width < Tour360Processor.MIN_WIDTH:
                    return False, f"Image too small. Minimum width: {Tour360Processor.MIN_WIDTH}px"
                
                if not (1.8 <= aspect_ratio <= 2.2):
                    return False, f"Invalid aspect ratio {aspect_ratio:.2f}. Expected 2:1 for equirectangular"
                
                return True, "Valid 360° image"
        except Exception as e:
            return False, f"Error reading image: {str(e)}"
    
    @staticmethod
    async def process_360_image(image_path: str, tour_dir: Path, scene_name: str) -> dict:
        """Process and optimize 360° image"""
        try:
            processed_path = tour_dir / f"{scene_name}_360.jpg"
            thumbnail_path = tour_dir / f"{scene_name}_thumb.jpg"
            
            with Image.open(image_path) as img:
                # Convert RGBA to RGB
                if img.mode == 'RGBA':
                    background = Image.new('RGB', img.size, (255, 255, 255))
                    background.paste(img, mask=img.split()[3])
                    img = background
                
                # Resize if needed
                if img.width > Tour360Processor.WEB_WIDTH:
                    new_height = int(img.height * Tour360Processor.WEB_WIDTH / img.width)
                    img = img.resize((Tour360Processor.WEB_WIDTH, new_height), Image.Resampling.LANCZOS)
                
                # Save optimized version
                img.save(processed_path, "JPEG", quality=85, optimize=True, progressive=True)
                
                # Create thumbnail
                thumb = img.copy()
                thumb.thumbnail(Tour360Processor.THUMBNAIL_SIZE, Image.Resampling.LANCZOS)
                thumb.save(thumbnail_path, "JPEG", quality=80, optimize=True)
            
            return {
                "success": True,
                "processed_path": str(processed_path.name),
                "thumbnail_path": str(thumbnail_path.name)
            }
        except Exception as e:
            logger.error(f"Error processing 360 image: {e}")
            return {"success": False, "error": str(e)}
    
    @staticmethod
    def generate_tour_html(tour_id: str, scenes: List[dict]) -> str:
        """Generate interactive 360° tour viewer using Pannellum"""
        
        scenes_json = json.dumps(scenes, indent=2)
        
        return f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Virtual Tour</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css"/>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #000; }}
        #panorama {{ width: 100vw; height: 100vh; }}
        .tour-header {{
            position: fixed; top: 0; left: 0; right: 0; z-index: 1000;
            background: linear-gradient(180deg, rgba(0,0,0,0.8), transparent);
            padding: 20px; display: flex; justify-content: space-between; align-items: center;
        }}
        .tour-title {{ color: white; font-size: 24px; font-weight: 600; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }}
        .fullscreen-btn {{
            background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.5);
            color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer;
            backdrop-filter: blur(10px); transition: all 0.3s;
        }}
        .fullscreen-btn:hover {{ background: rgba(255,255,255,0.3); }}
        .scene-navigation {{
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); backdrop-filter: blur(10px);
            padding: 15px 25px; border-radius: 50px; display: flex; gap: 10px; z-index: 1000;
        }}
        .scene-btn {{
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3);
            color: white; padding: 10px 20px; border-radius: 25px; cursor: pointer;
            transition: all 0.3s; white-space: nowrap;
        }}
        .scene-btn:hover {{ background: rgba(255,255,255,0.2); transform: translateY(-2px); }}
        .scene-btn.active {{ background: rgba(255,255,255,0.9); color: #000; }}
        .controls-hint {{
            position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: white; padding: 12px 24px;
            border-radius: 8px; z-index: 1000; animation: fadeOut 5s forwards;
        }}
        @keyframes fadeOut {{ 0%, 70% {{ opacity: 1; }} 100% {{ opacity: 0; }} }}
    </style>
</head>
<body>
    <div class="tour-header">
        <div class="tour-title">Virtual Tour</div>
        <button class="fullscreen-btn" onclick="toggleFullscreen()">Fullscreen</button>
    </div>
    <div class="controls-hint">Click and drag to look around - Scroll to zoom</div>
    <div id="panorama"></div>
    <div class="scene-navigation" id="sceneNav"></div>
    
    <script src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"></script>
    <script>
        const scenes = {scenes_json};
        let viewer = null;
        let currentSceneIndex = 0;
        
        function initTour() {{
            const firstScene = scenes[0];
            viewer = pannellum.viewer('panorama', {{
                "default": {{ "firstScene": firstScene.id, "sceneFadeDuration": 1000, "autoLoad": true }},
                "scenes": {{}}
            }});
            
            scenes.forEach((scene, index) => {{
                const hotSpots = [];
                if (index < scenes.length - 1) {{
                    hotSpots.push({{
                        "pitch": -10, "yaw": 90, "type": "scene",
                        "text": scenes[index + 1].name,
                        "sceneId": scenes[index + 1].id,
                        "clickHandlerFunc": () => loadScene(index + 1)
                    }});
                }}
                if (index > 0) {{
                    hotSpots.push({{
                        "pitch": -10, "yaw": -90, "type": "scene",
                        "text": scenes[index - 1].name,
                        "sceneId": scenes[index - 1].id,
                        "clickHandlerFunc": () => loadScene(index - 1)
                    }});
                }}
                
                viewer.addScene(scene.id, {{
                    "type": "equirectangular",
                    "panorama": scene.panorama,
                    "pitch": scene.pitch || 0,
                    "yaw": scene.yaw || 0,
                    "hfov": scene.fov || 100,
                    "hotSpots": hotSpots
                }});
            }});
            
            generateSceneButtons();
            fetch('/api/tours/{tour_id}/view', {{ method: 'POST' }}).catch(e => console.log(e));
        }}
        
        function generateSceneButtons() {{
            const nav = document.getElementById('sceneNav');
            scenes.forEach((scene, index) => {{
                const btn = document.createElement('button');
                btn.className = 'scene-btn' + (index === 0 ? ' active' : '');
                btn.textContent = scene.name;
                btn.onclick = () => loadScene(index);
                nav.appendChild(btn);
            }});
        }}
        
        function loadScene(index) {{
            if (index < 0 || index >= scenes.length) return;
            currentSceneIndex = index;
            viewer.loadScene(scenes[index].id);
            document.querySelectorAll('.scene-btn').forEach((btn, i) => {{
                btn.classList.toggle('active', i === index);
            }});
        }}
        
        function toggleFullscreen() {{
            if (!document.fullscreenElement) {{
                document.documentElement.requestFullscreen();
            }} else {{
                document.exitFullscreen();
            }}
        }}
        
        document.addEventListener('keydown', (e) => {{
            if (e.key === 'ArrowLeft') loadScene(currentSceneIndex - 1);
            else if (e.key === 'ArrowRight') loadScene(currentSceneIndex + 1);
            else if (e.key === 'f') toggleFullscreen();
        }});
        
        window.addEventListener('load', initTour);
    </script>
</body>
</html>"""

# AI Content Engine
class AIContentEngine:
    """Generate viral content using OpenAI GPT-4"""
    
    PLATFORM_CONFIGS = {
        "instagram": {
            "max_length": 2200,
            "hashtags": (15, 30),
            "tone": "visual, aspirational, lifestyle"
        },
        "tiktok": {
            "max_length": 300,
            "hashtags": (5, 10),
            "tone": "energetic, trendy, authentic"
        },
        "facebook": {
            "max_length": 5000,
            "hashtags": (3, 8),
            "tone": "informative, community-focused"
        }
    }
    
    @staticmethod
    async def generate_viral_content(property_data: dict, platform: str) -> dict:
        """Generate platform-optimized viral content"""
        try:
            if not openai_client:
                return AIContentEngine._demo_content(property_data, platform)
            
            config = AIContentEngine.PLATFORM_CONFIGS.get(platform, AIContentEngine.PLATFORM_CONFIGS["instagram"])
            has_tour = property_data.get('has_tour', False)
            
            tour_emphasis = "\n\nIMPORTANT: This property has a 360° VIRTUAL TOUR! Emphasize this heavily." if has_tour else ""
            
            prompt = f"""Create viral {platform} content for this property:

Title: {property_data.get('title')}
Address: {property_data.get('address')}
Price: {property_data.get('price')}
Type: {property_data.get('property_type')}
Beds/Baths: {property_data.get('bedrooms')}/{property_data.get('bathrooms')}
Size: {property_data.get('square_feet')} sq ft
Description: {property_data.get('description')}
Features: {', '.join(property_data.get('features', []))}{tour_emphasis}

Create engaging content with {config['hashtags'][0]}-{config['hashtags'][1]} hashtags. Tone: {config['tone']}."""

            response = await openai_client.chat.completions.create(
                model="gpt-4-turbo-preview",
                messages=[
                    {"role": "system", "content": f"You are a viral real estate marketing expert for {platform}."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.8,
                max_tokens=600
            )
            
            content = response.choices[0].message.content
            hashtags = re.findall(r'#\w+', content)
            
            viral_score = 50 + len(hashtags) * 3 + len(content.split()) // 15
            if has_tour:
                viral_score += 15
            viral_score = min(viral_score, 100)
            
            return {
                "platform": platform,
                "content": content,
                "hashtags": hashtags[:30],
                "viral_score": viral_score,
                "ai_generated": True
            }
            
        except Exception as e:
            logger.error(f"AI generation error: {e}")
            return AIContentEngine._demo_content(property_data, platform)
    
    @staticmethod
    def _demo_content(property_data: dict, platform: str) -> dict:
        """Fallback demo content"""
        has_tour = property_data.get('has_tour', False)
        tour_text = "\n\nVIRTUAL 360° TOUR AVAILABLE! Explore every room interactively!" if has_tour else ""
        
        content = f"""{property_data.get('title', 'Stunning Property').upper()}

{property_data.get('address')}
{property_data.get('price')}
{property_data.get('bedrooms')} beds | {property_data.get('bathrooms')} baths

{property_data.get('description', 'Beautiful property')}{tour_text}

Don't miss this opportunity!

#RealEstate #DreamHome #Property #HomeForSale #VirtualTour #NewListing #{platform.title()}"""
        
        return {
            "platform": platform,
            "content": content,
            "hashtags": ['#RealEstate', '#DreamHome', '#Property', '#HomeForSale'],
            "viral_score": 85 if has_tour else 70,
            "ai_generated": False
        }

# Routes
@api_router.post("/users", response_model=User)
async def create_user(user_data: UserCreate):
    """Create new user"""
    user_id = str(uuid.uuid4())
    async with aiosqlite.connect(DATABASE_PATH) as db:
        await db.execute(
            "INSERT INTO users (id, email, name) VALUES (?, ?, ?)",
            (user_id, user_data.email, user_data.name)
        )
        await db.commit()
    
    return User(id=user_id, **user_data.dict())

@api_router.post("/properties")
async def create_property(property_data: PropertyCreate, user_id: str):
    """Create property listing"""
    property_id = str(uuid.uuid4())
    
    async with aiosqlite.connect(DATABASE_PATH) as db:
        await db.execute(
            """INSERT INTO properties (id, user_id, title, description, address, price,
               property_type, bedrooms, bathrooms, square_feet, features)
               VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
            (property_id, user_id, property_data.title, property_data.description,
             property_data.address, property_data.price, property_data.property_type,
             property_data.bedrooms, property_data.bathrooms, property_data.square_feet,
             json.dumps(property_data.features))
        )
        await db.execute(
            "UPDATE users SET listings_created = listings_created + 1 WHERE id = ?",
            (user_id,)
        )
        await db.commit()
    
    return {"id": property_id, "message": "Property created successfully"}

@api_router.get("/properties/{user_id}")
async def get_user_properties(user_id: str):
    """Get all user properties"""
    async with aiosqlite.connect(DATABASE_PATH) as db:
        async with db.execute(
            "SELECT * FROM properties WHERE user_id = ? ORDER BY created_at DESC",
            (user_id,)
        ) as cursor:
            rows = await cursor.fetchall()
            return [{
                'id': row[0], 'user_id': row[1], 'title': row[2],
                'description': row[3], 'address': row[4], 'price': row[5],
                'property_type': row[6], 'bedrooms': row[7], 'bathrooms': row[8],
                'square_feet': row[9], 'features': json.loads(row[10] or '[]'),
                'has_tour': bool(row[11]), 'created_at': row[12]
            } for row in rows]

@api_router.post("/properties/{property_id}/upload-360")
async def upload_360_image(
    property_id: str,
    background_tasks: BackgroundTasks,
    file: UploadFile = File(...),
    scene_name: str = Form("Main Room")
):
    """Upload 360° image for virtual tour"""
    
    if not file.content_type.startswith('image/'):
        raise HTTPException(400, "File must be an image")
    
    async with aiosqlite.connect(DATABASE_PATH) as db:
        async with db.execute("SELECT id FROM properties WHERE id = ?", (property_id,)) as cursor:
            if not await cursor.fetchone():
                raise HTTPException(404, "Property not found")
    
    upload_path = UPLOAD_DIR / f"{uuid.uuid4()}_{file.filename}"
    with open(upload_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    
    is_valid, message = Tour360Processor.validate_360_image(str(upload_path))
    if not is_valid:
        os.remove(upload_path)
        raise HTTPException(400, message)
    
    tour_id = str(uuid.uuid4())
    async with aiosqlite.connect(DATABASE_PATH) as db:
        await db.execute(
            """INSERT INTO virtual_tours (id, property_id, tour_name, tour_url, processing_status)
               VALUES (?, ?, ?, ?, 'processing')""",
            (tour_id, property_id, f"{scene_name} Tour", f"/tours/{tour_id}/tour.html")
        )
        await db.commit()
    
    background_tasks.add_task(process_tour_background, tour_id, property_id, str(upload_path), scene_name)
    
    return {"tour_id": tour_id, "status": "processing", "message": "Processing 360° image..."}

async def process_tour_background(tour_id: str, property_id: str, image_path: str, scene_name: str):
    """Background processing for 360 tour"""
    try:
        tour_dir = TOURS_DIR / tour_id
        tour_dir.mkdir(exist_ok=True)
        
        result = await Tour360Processor.process_360_image(image_path, tour_dir, scene_name)
        
        if result["success"]:
            scene_id = str(uuid.uuid4())
            image_url = f"/tours/{tour_id}/{result['processed_path']}"
            thumbnail_url = f"/tours/{tour_id}/{result['thumbnail_path']}"
            
            async with aiosqlite.connect(DATABASE_PATH) as db:
                await db.execute(
                    """INSERT INTO tour_scenes (id, tour_id, scene_name, image_url, scene_order)
                       VALUES (?, ?, ?, ?, 0)""",
                    (scene_id, tour_id, scene_name, image_url)
                )
                
                async with db.execute(
                    "SELECT id, scene_name, image_url, pitch, yaw, fov FROM tour_scenes WHERE tour_id = ? ORDER BY scene_order",
                    (tour_id,)
                ) as cursor:
                    scenes = await cursor.fetchall()
                
                scene_data = [{
                    "id": f"scene_{s[0]}",
                    "name": s[1],
                    "panorama": s[2],
                    "pitch": s[3] or 0,
                    "yaw": s[4] or 0,
                    "fov": s[5] or 100
                } for s in scenes]
                
                tour_html = Tour360Processor.generate_tour_html(tour_id, scene_data)
                html_path = tour_dir / "tour.html"
                
                async with aiofiles.open(html_path, 'w') as f:
                    await f.write(tour_html)
                
                await db.execute(
                    """UPDATE virtual_tours SET processing_status = 'completed',
                       thumbnail_url = ?, scene_count = ? WHERE id = ?""",
                    (thumbnail_url, len(scenes), tour_id)
                )
                await db.execute(
                    "UPDATE properties SET has_tour = 1 WHERE id = ?",
                    (property_id,)
                )
                await db.commit()
                
                logger.info(f"Tour {tour_id} processed successfully")
        
        if os.path.exists(image_path):
            os.remove(image_path)
            
    except Exception as e:
        logger.error(f"Tour processing error: {e}")
        async with aiosqlite.connect(DATABASE_PATH) as db:
            await db.execute(
                "UPDATE virtual_tours SET processing_status = 'failed' WHERE id = ?",
                (tour_id,)
            )
            await db.commit()

@api_router.get("/properties/{property_id}/tours")
async def get_property_tours(property_id: str):
    """Get all tours for property"""
    async with aiosqlite.connect(DATABASE_PATH) as db:
        async with db.execute(
            "SELECT * FROM virtual_tours WHERE property_id = ?",
            (property_id,)
        ) as cursor:
            tours = await cursor.fetchall()
            return [{
                'id': t[0], 'property_id': t[1], 'tour_name': t[2],
                'tour_url': t[3], 'thumbnail_url': t[4], 'processing_status': t[5],
                'tour_type': t[6], 'scene_count': t[7], 'created_at': t[8]
            } for t in tours]

@api_router.post("/properties/{property_id}/viral-content")
async def generate_viral_content(property_id: str):
    """Generate AI-powered viral content"""
    async with aiosqlite.connect(DATABASE_PATH) as db:
        async with db.execute("SELECT * FROM properties WHERE id = ?", (property_id,)) as cursor:
            row = await cursor.fetchone()
            if not row:
                raise HTTPException(404, "Property not found")
            
            property_data = {
                'title': row[2], 'description': row[3], 'address': row[4],
                'price': row[5], 'property_type': row[6], 'bedrooms': row[7],
                'bathrooms': row[8], 'square_feet': row[9],
                'features': json.loads(row[10] or '[]'), 'has_tour': bool(row[11])
            }
    
    viral_contents = []
    platforms = ["instagram", "tiktok", "facebook"]
    
    for platform in platforms:
        content_data = await AIContentEngine.generate_viral_content(property_data, platform)
        content_id = str(uuid.uuid4())
        
        async with aiosqlite.connect(DATABASE_PATH) as db:
            await db.execute(
                """INSERT INTO viral_content (id, property_id, platform, content_type, content, viral_score, hashtags, ai_generated)
                   VALUES (?, ?, ?, 'caption', ?, ?, ?, ?)""",
                (content_id, property_id, platform, content_data['content'],
                 content_data['viral_score'], json.dumps(content_data['hashtags']),
                 content_data['ai_generated'])
            )
            await db.commit()
        
        viral_contents.append({
            'id': content_id,
            'property_id': property_id,
            'platform': platform,
            'content': content_data['content'],
            'viral_score': content_data['viral_score'],
            'hashtags': content_data['hashtags'],
            'ai_generated': content_data['ai_generated']
        })
    
    return {"message": "Viral content generated", "content": viral_contents}

@api_router.get("/properties/{property_id}/viral-content")
async def get_viral_content(property_id: str):
    """Get all viral content for property"""
    async with aiosqlite.connect(DATABASE_PATH) as db:
        async with db.execute(
            "SELECT * FROM viral_content WHERE property_id = ? ORDER BY created_at DESC",
            (property_id,)
        ) as cursor:
            rows = await cursor.fetchall()
            return [{
                'id': r[0], 'property_id': r[1], 'platform': r[2],
                'content_type': r[3], 'content': r[4], 'viral_score': r[5],
                'hashtags': json.loads(r[6] or '[]'), 'ai_generated': bool(r[7]),
                'created_at': r[8]
            } for r in rows]

@api_router.post("/tours/{tour_id}/view")
async def track_tour_view(tour_id: str):
    """Track virtual tour view for analytics"""
    async with aiosqlite.connect(DATABASE_PATH) as db:
        async with db.execute(
            "SELECT property_id FROM virtual_tours WHERE id = ?",
            (tour_id,)
        ) as cursor:
            row = await cursor.fetchone()
            if not row:
                raise HTTPException(404, "Tour not found")
            
            property_id = row[0]
        
        await db.execute(
            """INSERT INTO analytics (property_id, tour_views, views)
               VALUES (?, 1, 1)
               ON CONFLICT(property_id) DO UPDATE SET
               tour_views = tour_views + 1,
               views = views + 1,
               updated_at = CURRENT_TIMESTAMP""",
            (property_id,)
        )
        await db.commit()
    
    return {"message": "View tracked"}

@api_router.get("/properties/{property_id}/analytics")
async def get_analytics(property_id: str):
    """Get property analytics"""
    async with aiosqlite.connect(DATABASE_PATH) as db:
        async with db.execute(
            "SELECT * FROM analytics WHERE property_id = ?",
            (property_id,)
        ) as cursor:
            row = await cursor.fetchone()
            
            if not row:
                await db.execute(
                    "INSERT INTO analytics (property_id) VALUES (?)",
                    (property_id,)
                )
                await db.commit()
                return {
                    "property_id": property_id, "views": 0, "shares": 0,
                    "engagement_rate": 0.0, "viral_score": 0, "tour_views": 0
                }
            
            return {
                "property_id": row[0], "views": row[1], "shares": row[2],
                "engagement_rate": row[3], "viral_score": row[4],
                "tour_views": row[5], "trending_status": row[6]
            }

@api_router.get("/dashboard/{user_id}")
async def get_dashboard(user_id: str):
    """Get user dashboard statistics"""
    async with aiosqlite.connect(DATABASE_PATH) as db:
        async with db.execute("SELECT * FROM users WHERE id = ?", (user_id,)) as cursor:
            user_row = await cursor.fetchone()
            if not user_row:
                raise HTTPException(404, "User not found")
        
        async with db.execute(
            "SELECT id, has_tour FROM properties WHERE user_id = ?",
            (user_id,)
        ) as cursor:
            properties = await cursor.fetchall()
        
        total_views = 0
        total_shares = 0
        total_tour_views = 0
        properties_with_tours = sum(1 for p in properties if p[1])
        
        for prop in properties:
            async with db.execute(
                "SELECT views, shares, tour_views FROM analytics WHERE property_id = ?",
                (prop[0],)
            ) as cursor:
                analytics = await cursor.fetchone()
                if analytics:
                    total_views += analytics[0]
                    total_shares += analytics[1]
                    total_tour_views += analytics[2]
        
        return {
            "user": {
                "id": user_row[0],
                "email": user_row[1],
                "name": user_row[2],
                "plan": user_row[3],
                "listings_created": user_row[4]
            },
            "stats": {
                "total_properties": len(properties),
                "properties_with_tours": properties_with_tours,
                "total_views": total_views,
                "total_shares": total_shares,
                "total_tour_views": total_tour_views,
                "engagement_rate": round((total_shares / total_views * 100) if total_views > 0 else 0, 2)
            }
        }

@api_router.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "openai_configured": openai_client is not None,
        "database": "connected",
        "timestamp": datetime.utcnow().isoformat()
    }

# Include router
app.include_router(api_router)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.on_event("startup")
async def startup():
    await init_db()
    logger.info("=" * 60)
    logger.info("ListingSpark AI Backend Started!")
    logger.info(f"OpenAI Integration: {'Enabled' if openai_client else 'Demo Mode'}")
    logger.info(f"Database: {DATABASE_PATH}")
    logger.info(f"Tours Directory: {TOURS_DIR}")
    logger.info("=" * 60)

@app.on_event("shutdown")
async def shutdown():
    logger.info("Shutting down ListingSpark AI Backend")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
