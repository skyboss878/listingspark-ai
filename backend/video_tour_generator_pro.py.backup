"""
ListingSpark AI - Professional Video Tour Generator
Premium features that command professional pricing
"""

import os
import logging
import asyncio
from pathlib import Path
from typing import List, Dict, Optional, Tuple
import json
from dataclasses import dataclass
from datetime import datetime

logger = logging.getLogger(__name__)


@dataclass
class BrandingConfig:
    """Agent/Agency branding configuration"""
    logo_path: Optional[str] = None
    agent_name: str = ""
    agency_name: str = ""
    phone: str = ""
    email: str = ""
    website: str = ""
    license_number: str = ""
    brand_color: str = "#1E40AF"  # Hex color for overlays
    watermark_position: str = "bottom-right"  # top-left, top-right, bottom-left, bottom-right


@dataclass
class VideoConfig:
    """Video generation configuration"""
    resolution: str = "1920x1080"  # 1080p, 4K available
    fps: int = 30
    format: str = "landscape"  # landscape, square, vertical
    quality: str = "high"  # low, medium, high, ultra
    voice_provider: str = "elevenlabs"  # edge-tts, elevenlabs
    voice_id: str = "professional_female"
    music_genre: str = "upbeat"
    music_volume: float = 0.2
    narration_speed: float = 1.0
    transition_style: str = "crossfade"  # crossfade, zoom, slide
    include_captions: bool = True
    include_property_stats: bool = True


class PremiumVoiceEngine:
    """Handle multiple TTS providers for premium quality"""
    
    def __init__(self):
        self.elevenlabs_key = os.getenv("ELEVENLABS_API_KEY")
        
        # Professional voice options
        self.voices = {
            "professional_female": {
                "elevenlabs": "EXAVITQu4vr4xnSDxMaL",  # Bella - professional
                "edge": "en-US-AriaNeural",
                "description": "Warm, professional female voice"
            },
            "professional_male": {
                "elevenlabs": "VR6AewLTigWG4xSOukaG",  # Arnold - authoritative
                "edge": "en-US-GuyNeural",
                "description": "Deep, authoritative male voice"
            },
            "friendly_female": {
                "elevenlabs": "21m00Tcm4TlvDq8ikWAM",  # Rachel - friendly
                "edge": "en-US-JennyNeural",
                "description": "Friendly, approachable female"
            },
            "luxury_british": {
                "elevenlabs": "ThT5KcBeYPX3keUQqHPh",  # Dorothy - British accent
                "edge": "en-GB-SoniaNeural",
                "description": "Sophisticated British accent for luxury properties"
            }
        }
    
    async def generate_speech_elevenlabs(
        self,
        text: str,
        voice_id: str,
        output_file: Path
    ) -> Path:
        """Generate speech using ElevenLabs (premium quality)"""
        import aiohttp
        
        url = f"https://api.elevenlabs.io/v1/text-to-speech/{voice_id}"
        
        headers = {
            "Accept": "audio/mpeg",
            "Content-Type": "application/json",
            "xi-api-key": self.elevenlabs_key
        }
        
        data = {
            "text": text,
            "model_id": "eleven_monolingual_v1",
            "voice_settings": {
                "stability": 0.5,
                "similarity_boost": 0.75,
                "style": 0.5,
                "use_speaker_boost": True
            }
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(url, json=data, headers=headers) as response:
                if response.status == 200:
                    audio_data = await response.read()
                    output_file.write_bytes(audio_data)
                    return output_file
                else:
                    raise Exception(f"ElevenLabs API error: {response.status}")
    
    async def generate_speech_edge(
        self,
        text: str,
        voice: str,
        output_file: Path
    ) -> Path:
        """Generate speech using Edge TTS (free fallback)"""
        import edge_tts
        
        communicate = edge_tts.Communicate(text, voice)
        await communicate.save(str(output_file))
        return output_file
    
    async def generate_speech(
        self,
        text: str,
        voice_option: str,
        provider: str,
        output_file: Path
    ) -> Path:
        """Generate speech using configured provider"""
        voice_config = self.voices.get(voice_option, self.voices["professional_female"])
        
        if provider == "elevenlabs" and self.elevenlabs_key:
            return await self.generate_speech_elevenlabs(
                text,
                voice_config["elevenlabs"],
                output_file
            )
        else:
            return await self.generate_speech_edge(
                text,
                voice_config["edge"],
                output_file
            )


class VideoEffectsEngine:
    """Advanced video effects and transitions"""
    
    @staticmethod
    def create_title_card(
        property_data: dict,
        branding: BrandingConfig,
        output_file: Path,
        duration: int = 3
    ) -> Path:
        """Create professional opening title card"""
        from PIL import Image, ImageDraw, ImageFont
        
        # Create 1920x1080 image
        img = Image.new('RGB', (1920, 1080), color=(30, 30, 30))
        draw = ImageDraw.Draw(img)
        
        # Try to load custom fonts, fallback to default
        try:
            title_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 80)
            subtitle_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 40)
            info_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 30)
        except:
            title_font = ImageFont.load_default()
            subtitle_font = ImageFont.load_default()
            info_font = ImageFont.load_default()
        
        # Add property title
        title = property_data['title']
        bbox = draw.textbbox((0, 0), title, font=title_font)
        title_width = bbox[2] - bbox[0]
        draw.text(
            ((1920 - title_width) // 2, 400),
            title,
            fill=(255, 255, 255),
            font=title_font
        )
        
        # Add price
        price = f"${property_data['price']}"
        bbox = draw.textbbox((0, 0), price, font=subtitle_font)
        price_width = bbox[2] - bbox[0]
        draw.text(
            ((1920 - price_width) // 2, 520),
            price,
            fill=(100, 200, 100),
            font=subtitle_font
        )
        
        # Add specs
        specs = f"{property_data['bedrooms']} BD | {property_data['bathrooms']} BA | {property_data['square_feet']} SqFt"
        bbox = draw.textbbox((0, 0), specs, font=info_font)
        specs_width = bbox[2] - bbox[0]
        draw.text(
            ((1920 - specs_width) // 2, 600),
            specs,
            fill=(200, 200, 200),
            font=info_font
        )
        
        # Add branding at bottom
        if branding.agent_name:
            agent_text = f"Presented by {branding.agent_name}"
            if branding.agency_name:
                agent_text += f" | {branding.agency_name}"
            bbox = draw.textbbox((0, 0), agent_text, font=info_font)
            agent_width = bbox[2] - bbox[0]
            draw.text(
                ((1920 - agent_width) // 2, 950),
                agent_text,
                fill=(150, 150, 150),
                font=info_font
            )
        
        img.save(output_file)
        return output_file
    
    @staticmethod
    def create_contact_card(
        branding: BrandingConfig,
        output_file: Path,
        duration: int = 5
    ) -> Path:
        """Create ending contact/CTA card"""
        from PIL import Image, ImageDraw, ImageFont
        
        img = Image.new('RGB', (1920, 1080), color=(20, 30, 50))
        draw = ImageDraw.Draw(img)
        
        try:
            title_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 70)
            info_font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 45)
        except:
            title_font = ImageFont.load_default()
            info_font = ImageFont.load_default()
        
        # CTA text
        cta = "Schedule Your Private Showing"
        bbox = draw.textbbox((0, 0), cta, font=title_font)
        cta_width = bbox[2] - bbox[0]
        draw.text(
            ((1920 - cta_width) // 2, 300),
            cta,
            fill=(255, 255, 255),
            font=title_font
        )
        
        # Contact info
        y_pos = 450
        contact_items = [
            branding.agent_name,
            branding.phone,
            branding.email,
            branding.website
        ]
        
        for item in contact_items:
            if item:
                bbox = draw.textbbox((0, 0), item, font=info_font)
                item_width = bbox[2] - bbox[0]
                draw.text(
                    ((1920 - item_width) // 2, y_pos),
                    item,
                    fill=(200, 220, 255),
                    font=info_font
                )
                y_pos += 80
        
        img.save(output_file)
        return output_file
    
    @staticmethod
    async def add_watermark_and_branding(
        video_file: Path,
        branding: BrandingConfig,
        output_file: Path
    ) -> Path:
        """Add logo watermark and branding overlay"""
        import subprocess
        
        if not branding.logo_path or not Path(branding.logo_path).exists():
            # No logo, just copy
            output_file.write_bytes(video_file.read_bytes())
            return output_file
        
        # Position mapping
        positions = {
            "top-left": "10:10",
            "top-right": "main_w-overlay_w-10:10",
            "bottom-left": "10:main_h-overlay_h-10",
            "bottom-right": "main_w-overlay_w-10:main_h-overlay_h-10"
        }
        
        position = positions.get(branding.watermark_position, positions["bottom-right"])
        
        cmd = [
            'ffmpeg', '-y',
            '-i', str(video_file),
            '-i', branding.logo_path,
            '-filter_complex',
            f'[1:v]scale=150:-1[logo];[0:v][logo]overlay={position}:format=auto',
            '-codec:a', 'copy',
            str(output_file)
        ]
        
        subprocess.run(cmd, check=True, capture_output=True)
        return output_file


class ProfessionalVideoTourGenerator:
    """Premium video tour generation with all professional features"""
    
    def __init__(self):
        self.output_dir = Path("video_tours")
        self.output_dir.mkdir(exist_ok=True)
        self.music_dir = Path("music_library")
        self.music_dir.mkdir(exist_ok=True)
        self.voice_engine = PremiumVoiceEngine()
        self.effects_engine = VideoEffectsEngine()
    
    async def generate_premium_script(
        self,
        property_data: dict,
        rooms: List[dict],
        style: str = "professional"  # professional, luxury, family-friendly
    ) -> dict:
        """Generate AI-optimized narration script"""
        from openai import AsyncOpenAI
        
        client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        
        style_prompts = {
            "professional": "professional, informative tone focusing on features and benefits",
            "luxury": "sophisticated, elegant language emphasizing luxury and exclusivity",
            "family-friendly": "warm, welcoming tone highlighting family living and community"
        }
        
        prompt = f"""You are a top real estate marketing copywriter. Create a compelling video tour narration script.

Property Details:
- Title: {property_data['title']}
- Address: {property_data['address']}
- Price: ${property_data['price']}
- Type: {property_data['property_type']}
- Beds: {property_data['bedrooms']} | Baths: {property_data['bathrooms']}
- Square Feet: {property_data['square_feet']}
- Features: {', '.join(property_data.get('features', []))}

Rooms ({len(rooms)} total):
{json.dumps([{'name': r['space_name'], 'type': r['space_type'], 'description': r.get('description', '')} for r in rooms], indent=2)}

Style: {style_prompts[style]}

Requirements:
1. INTRO (5-8 seconds): Hook viewers immediately with the property's best selling point
2. ROOM NARRATIONS (15-20 seconds each): 
   - Highlight unique features
   - Use sensory language (imagine, picture, feel)
   - Mention dimensions/details naturally
   - Smooth transitions between rooms
3. OUTRO (5-8 seconds): Strong call-to-action, create urgency

Make it engaging enough for social media while remaining professional.
Use natural, conversational language a person would actually say.

Return ONLY valid JSON in this exact format:
{{
  "intro": "string",
  "rooms": [
    {{"room_name": "string", "narration": "string"}}
  ],
  "outro": "string",
  "estimated_duration_seconds": number
}}"""

        response = await client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            response_format={"type": "json_object"},
            temperature=0.8
        )
        
        return json.loads(response.choices[0].message.content)
    
    async def generate_tour_video(
        self,
        property_id: str,
        property_data: dict,
        rooms: List[dict],
        config: VideoConfig,
        branding: BrandingConfig
    ) -> Dict:
        """Generate complete professional video tour"""
        try:
            logger.info(f"Starting premium video generation for {property_id}")
            
            # Step 1: Generate script
            script = await self.generate_premium_script(property_data, rooms)
            
            # Step 2: Create working directory
            work_dir = self.output_dir / property_id
            work_dir.mkdir(parents=True, exist_ok=True)
            
            # Step 3: Generate all audio
            audio_files = []
            
            # Intro audio
            intro_audio = work_dir / "audio_intro.mp3"
            await self.voice_engine.generate_speech(
                script['intro'],
                config.voice_id,
                config.voice_provider,
                intro_audio
            )
            audio_files.append(intro_audio)
            
            # Room narrations
            for i, room_narration in enumerate(script['rooms']):
                room_audio = work_dir / f"audio_room_{i}.mp3"
                await self.voice_engine.generate_speech(
                    room_narration['narration'],
                    config.voice_id,
                    config.voice_provider,
                    room_audio
                )
                audio_files.append(room_audio)
            
            # Outro audio
            outro_audio = work_dir / "audio_outro.mp3"
            await self.voice_engine.generate_speech(
                script['outro'],
                config.voice_id,
                config.voice_provider,
                outro_audio
            )
            audio_files.append(outro_audio)
            
            # Step 4: Create title and contact cards
            title_card = work_dir / "title_card.png"
            self.effects_engine.create_title_card(property_data, branding, title_card)
            
            contact_card = work_dir / "contact_card.png"
            self.effects_engine.create_contact_card(branding, contact_card)
            
            # Step 5: Compile video segments
            # ... (continued in next message)
            
            return {
                "success": True,
                "video_url": f"/video_tours/{property_id}/final_tour.mp4",
                "script": script,
                "duration": script.get('estimated_duration_seconds', 0)
            }
            
        except Exception as e:
            logger.error(f"Premium video generation failed: {e}", exc_info=True)
            return {"success": False, "error": str(e)}


# Global instance
premium_video_generator = ProfessionalVideoTourGenerator()

    async def assemble_final_video(
        self,
        work_dir: Path,
        title_card: Path,
        contact_card: Path,
        room_images: List[Path],
        audio_files: List[Path],
        music_file: Optional[Path],
        config: VideoConfig,
        branding: BrandingConfig
    ) -> Path:
        """Assemble all components into final polished video"""
        import subprocess
        
        segments = []
        
        # 1. Create title card video (3 seconds)
        title_video = work_dir / "seg_000_title.mp4"
        cmd = [
            'ffmpeg', '-y', '-loop', '1',
            '-i', str(title_card),
            '-i', str(audio_files[0]),  # Intro audio
            '-c:v', 'libx264', '-t', '3',
            '-pix_fmt', 'yuv420p',
            '-vf', f'scale={config.resolution}',
            str(title_video)
        ]
        subprocess.run(cmd, check=True, capture_output=True)
        segments.append(title_video)
        
        # 2. Create room segments with Ken Burns effect
        for i, (img, audio) in enumerate(zip(room_images, audio_files[1:-1]), start=1):
            segment_file = work_dir / f"seg_{i:03d}_room.mp4"
            
            # Get audio duration
            probe_cmd = [
                'ffprobe', '-v', 'error',
                '-show_entries', 'format=duration',
                '-of', 'default=noprint_wrappers=1:nokey=1',
                str(audio)
            ]
            duration = float(subprocess.check_output(probe_cmd).decode().strip())
            
            # Ken Burns zoom effect for visual interest
            zoom_effect = (
                f'[0:v]scale=2160:1080,zoompan='
                f'z=\'if(lte(zoom,1.0),1.5,max(1.001,zoom-0.0015))\':'
                f'd={int(duration * 30)}:s={config.resolution.replace("x", ":")},'
                f'fade=t=in:st=0:d=0.5,fade=t=out:st={duration-0.5}:d=0.5[v]'
            )
            
            cmd = [
                'ffmpeg', '-y',
                '-loop', '1', '-i', str(img),
                '-i', str(audio),
                '-filter_complex', zoom_effect,
                '-map', '[v]', '-map', '1:a',
                '-c:v', 'libx264', '-preset', 'medium',
                '-c:a', 'aac', '-b:a', '192k',
                '-shortest', '-t', str(duration),
                str(segment_file)
            ]
            subprocess.run(cmd, check=True, capture_output=True)
            segments.append(segment_file)
        
        # 3. Create contact card video (5 seconds with outro audio)
        contact_video = work_dir / f"seg_{len(segments):03d}_contact.mp4"
        cmd = [
            'ffmpeg', '-y', '-loop', '1',
            '-i', str(contact_card),
            '-i', str(audio_files[-1]),  # Outro audio
            '-c:v', 'libx264', '-t', '5',
            '-pix_fmt', 'yuv420p',
            '-vf', f'scale={config.resolution}',
            str(contact_video)
        ]
        subprocess.run(cmd, check=True, capture_output=True)
        segments.append(contact_video)
        
        # 4. Concatenate all segments
        concat_file = work_dir / "concat_list.txt"
        with open(concat_file, 'w') as f:
            for seg in segments:
                f.write(f"file '{seg.name}'\n")
        
        temp_video = work_dir / "temp_concatenated.mp4"
        concat_cmd = [
            'ffmpeg', '-y',
            '-f', 'concat', '-safe', '0',
            '-i', str(concat_file),
            '-c', 'copy',
            str(temp_video)
        ]
        subprocess.run(concat_cmd, check=True, capture_output=True)
        
        # 5. Add background music if provided
        if music_file and music_file.exists():
            with_music = work_dir / "temp_with_music.mp4"
            music_cmd = [
                'ffmpeg', '-y',
                '-i', str(temp_video),
                '-stream_loop', '-1', '-i', str(music_file),
                '-filter_complex',
                f'[1:a]volume={config.music_volume}[music];'
                f'[0:a][music]amix=inputs=2:duration=first:dropout_transition=2[a]',
                '-map', '0:v', '-map', '[a]',
                '-c:v', 'copy', '-c:a', 'aac',
                '-shortest',
                str(with_music)
            ]
            subprocess.run(music_cmd, check=True, capture_output=True)
            temp_video.unlink()
            temp_video = with_music
        
        # 6. Add watermark/logo if configured
        final_output = work_dir / "final_tour.mp4"
        if branding.logo_path and Path(branding.logo_path).exists():
            await self.effects_engine.add_watermark_and_branding(
                temp_video, branding, final_output
            )
            temp_video.unlink()
        else:
            temp_video.rename(final_output)
        
        # 7. Cleanup intermediate files
        for seg in segments:
            seg.unlink()
        concat_file.unlink()
        
        return final_output
    
    async def export_for_social_platforms(
        self,
        source_video: Path,
        work_dir: Path
    ) -> Dict[str, Path]:
        """Export optimized versions for different social platforms"""
        import subprocess
        
        exports = {}
        
        # Instagram Feed (1:1 square)
        instagram_square = work_dir / "instagram_square.mp4"
        cmd = [
            'ffmpeg', '-y', '-i', str(source_video),
            '-vf', 'scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:(ow-iw)/2:(oh-ih)/2',
            '-c:v', 'libx264', '-preset', 'fast',
            '-b:v', '3500k', '-maxrate', '3500k', '-bufsize', '7000k',
            '-c:a', 'aac', '-b:a', '128k',
            str(instagram_square)
        ]
        subprocess.run(cmd, check=True, capture_output=True)
        exports['instagram_square'] = instagram_square
        
        # Instagram Stories/Reels (9:16 vertical)
        instagram_vertical = work_dir / "instagram_stories.mp4"
        cmd = [
            'ffmpeg', '-y', '-i', str(source_video),
            '-vf', 'scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920',
            '-c:v', 'libx264', '-preset', 'fast',
            '-b:v', '3500k', '-maxrate', '3500k', '-bufsize', '7000k',
            '-c:a', 'aac', '-b:a', '128k',
            '-t', '60',  # Max 60 seconds for stories
            str(instagram_vertical)
        ]
        subprocess.run(cmd, check=True, capture_output=True)
        exports['instagram_stories'] = instagram_vertical
        
        # TikTok (9:16 vertical, optimized)
        tiktok = work_dir / "tiktok.mp4"
        cmd = [
            'ffmpeg', '-y', '-i', str(source_video),
            '-vf', 'scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920',
            '-c:v', 'libx264', '-preset', 'fast',
            '-b:v', '4000k', '-maxrate', '4000k',
            '-c:a', 'aac', '-b:a', '192k', '-ar', '44100',
            '-t', '180',  # Max 3 minutes
            str(tiktok)
        ]
        subprocess.run(cmd, check=True, capture_output=True)
        exports['tiktok'] = tiktok
        
        # YouTube (16:9, high quality)
        youtube = work_dir / "youtube.mp4"
        cmd = [
            'ffmpeg', '-y', '-i', str(source_video),
            '-c:v', 'libx264', '-preset', 'slow', '-crf', '18',
            '-c:a', 'aac', '-b:a', '192k',
            '-movflags', '+faststart',
            str(youtube)
        ]
        subprocess.run(cmd, check=True, capture_output=True)
        exports['youtube'] = youtube
        
        # Facebook (landscape, optimized)
        facebook = work_dir / "facebook.mp4"
        cmd = [
            'ffmpeg', '-y', '-i', str(source_video),
            '-c:v', 'libx264', '-preset', 'fast',
            '-b:v', '4000k', '-maxrate', '4000k',
            '-c:a', 'aac', '-b:a', '128k',
            str(facebook)
        ]
        subprocess.run(cmd, check=True, capture_output=True)
        exports['facebook'] = facebook
        
        return exports
    
    async def generate_tour_video(
        self,
        property_id: str,
        property_data: dict,
        rooms: List[dict],
        config: VideoConfig,
        branding: BrandingConfig,
        export_social: bool = True
    ) -> Dict:
        """Complete professional video tour generation"""
        try:
            start_time = datetime.now()
            logger.info(f"Starting premium video generation for {property_id}")
            
            # Step 1: Generate script
            script = await self.generate_premium_script(property_data, rooms)
            
            # Step 2: Setup directories
            work_dir = self.output_dir / property_id
            work_dir.mkdir(parents=True, exist_ok=True)
            
            # Step 3: Generate all audio narration
            audio_files = []
            
            intro_audio = work_dir / "audio_intro.mp3"
            await self.voice_engine.generate_speech(
                script['intro'], config.voice_id, config.voice_provider, intro_audio
            )
            audio_files.append(intro_audio)
            
            for i, room_narration in enumerate(script['rooms']):
                room_audio = work_dir / f"audio_room_{i}.mp3"
                await self.voice_engine.generate_speech(
                    room_narration['narration'], config.voice_id, 
                    config.voice_provider, room_audio
                )
                audio_files.append(room_audio)
            
            outro_audio = work_dir / "audio_outro.mp3"
            await self.voice_engine.generate_speech(
                script['outro'], config.voice_id, config.voice_provider, outro_audio
            )
            audio_files.append(outro_audio)
            
            # Step 4: Create title and contact cards
            title_card = work_dir / "title_card.png"
            self.effects_engine.create_title_card(property_data, branding, title_card)
            
            contact_card = work_dir / "contact_card.png"
            self.effects_engine.create_contact_card(branding, contact_card)
            
            # Step 5: Get room images
            room_images = []
            for room in rooms:
                if room.get('image_360_url'):
                    img_path = Path(room['image_360_url'].replace('/tours/', 'tours/'))
                    if img_path.exists():
                        room_images.append(img_path)
            
            if len(room_images) != len(script['rooms']):
                raise ValueError(f"Image/narration mismatch: {len(room_images)} images, {len(script['rooms'])} narrations")
            
            # Step 6: Select background music
            music_file = self.music_dir / f"{config.music_genre}.mp3"
            if not music_file.exists():
                music_file = None
            
            # Step 7: Assemble final video
            final_video = await self.assemble_final_video(
                work_dir, title_card, contact_card, room_images,
                audio_files, music_file, config, branding
            )
            
            # Step 8: Export for social platforms
            social_exports = {}
            if export_social:
                social_exports = await self.export_for_social_platforms(final_video, work_dir)
            
            duration = (datetime.now() - start_time).total_seconds()
            
            logger.info(f"Video generation completed in {duration:.1f}s")
            
            return {
                "success": True,
                "video_url": f"/video_tours/{property_id}/final_tour.mp4",
                "video_path": str(final_video),
                "script": script,
                "duration_seconds": script.get('estimated_duration_seconds', 0),
                "processing_time_seconds": duration,
                "social_exports": {
                    platform: f"/video_tours/{property_id}/{path.name}"
                    for platform, path in social_exports.items()
                },
                "file_sizes": {
                    "main": final_video.stat().st_size,
                    **{k: v.stat().st_size for k, v in social_exports.items()}
                }
            }
            
        except Exception as e:
            logger.error(f"Premium video generation failed: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e),
                "property_id": property_id
            }


# Global instance
premium_video_generator = ProfessionalVideoTourGenerator()
